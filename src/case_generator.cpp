/**
 * ==================================================================================
 * @file        case_generator.cpp
 * @brief       算例生成器实现
 * @version     1.0.0
 * @date        2025-10-13
 *
 * @description
 * 本文件实现了批量大小问题算例生成器的核心功能：
 * 1. 配置验证 (Validate): 检查所有参数的合法性
 * 2. CSV生成 (GenerateCsv): 按标准格式生成CSV算例文件
 *
 * 验证内容包括：
 * - 规模参数的合法性（U, I, T必须为正）
 * - 向量长度的一致性（成本和产能占用向量长度必须等于I）
 * - 索引的有效性（所有索引不能越界）
 * - 数值的合理性（成本、产能等必须非负）
 * - 转运配置的完整性（当启用转运时）
 *
 * CSV输出格式：
 * section,key,u,v,i,t,value
 * - section: 数据段名称（meta/cost/cap_usage/capacity/init/demand/transfer/bigM/solver）
 * - key: 数据键名（如U, I, T, cX, cY等）
 * - u,v,i,t: 索引（不适用时为空）
 * - value: 数据值
 *
 * @author      LS-Game-DataGen Team
 * @note        -1 在CSV中表示空值（不适用的索引）
 * ==================================================================================
 */

#include "case_generator.h"
#include <unordered_set>
#include <sstream>

// ====================================================================================
// 内部辅助函数
// ====================================================================================

/**
 * @brief 条件检查宏，不满足条件时抛出异常
 *
 * @param cond 要检查的条件
 * @param msg  错误信息
 *
 * @throw std::runtime_error 当条件不满足时抛出
 */
static void CHECK(bool cond, const std::string& msg) {
    if (!cond) throw std::runtime_error("配置不合法: " + msg);
}

/**
 * @brief 格式化三元组为字符串 (a, b, c)
 *
 * @param a 第一个值
 * @param b 第二个值
 * @param c 第三个值
 * @return std::string 格式化后的字符串
 */
static std::string triple(int a, int b, int c) {
    return "(" + std::to_string(a) + "," + std::to_string(b) + "," + std::to_string(c) + ")";
}

/**
 * @brief 格式化四元组为字符串 (a, b, c, d)
 *
 * @param a 第一个值
 * @param b 第二个值
 * @param c 第三个值
 * @param d 第四个值
 * @return std::string 格式化后的字符串
 */
static std::string quad(int a, int b, int c, int d) {
    return "(" + std::to_string(a) + "," + std::to_string(b) + "," + std::to_string(c) + "," + std::to_string(d) + ")";
}

// ====================================================================================
// CaseGenerator 类方法实现
// ====================================================================================

/**
 * @brief 验证算例生成配置的合法性
 *
 * @param g 待验证的配置对象
 *
 * @throw std::runtime_error 当配置不合法时抛出异常，附带详细错误信息
 *
 * @details
 * 验证顺序：
 * 1. 基本规模参数（U, I, T必须为正整数）
 * 2. 成本向量长度（cX, cY, cI长度必须等于I）
 * 3. 产能占用向量长度（sX, sY长度必须等于I）
 * 4. 默认值合法性（产能和初始库存必须非负）
 * 5. 求解器参数合法性
 * 6. 需求数据索引和值的合法性
 * 7. 产能覆盖数据的合法性
 * 8. 初始库存覆盖数据的合法性
 * 9. 转运配置的合法性（如果启用）
 * 10. BigM配置的合法性（如果启用）
 */
void CaseGenerator::Validate(const GeneratorConfig& g) {
    // ================================================================================
    // 1. 验证基本规模参数
    // ================================================================================
    CHECK(g.U > 0 && g.I > 0 && g.T > 0, "U/I/T 必须为正整数");

    // ================================================================================
    // 2. 验证成本向量长度
    // ================================================================================
    // 每个物品都必须有对应的成本参数
    CHECK((int)g.cX.size() == g.I, "cX 长度必须等于 I");
    CHECK((int)g.cY.size() == g.I, "cY 长度必须等于 I");
    CHECK((int)g.cI.size() == g.I, "cI 长度必须等于 I");

    // ================================================================================
    // 3. 验证产能占用向量长度
    // ================================================================================
    // 每个物品都必须有对应的产能占用参数
    CHECK((int)g.sX.size() == g.I, "sX 长度必须等于 I");
    CHECK((int)g.sY.size() == g.I, "sY 长度必须等于 I");

    // ================================================================================
    // 4. 验证默认值合法性
    // ================================================================================
    // 产能和初始库存必须为非负值
    CHECK(g.default_capacity >= 0.0, "default_capacity 需为非负");
    CHECK(g.default_i0 >= 0.0, "default_i0 需为非负");

    // ================================================================================
    // 5. 验证求解器参数
    // ================================================================================
    CHECK(g.mip_gap >= 0.0, "mip_gap 非负");
    CHECK(g.time_limit_sec > 0, "time_limit_sec 必须 > 0");
    CHECK(g.max_iters > 0, "max_iters 必须 > 0");

    // ================================================================================
    // 6. 验证需求数据
    // ================================================================================
    // 检查每个需求点的索引和值是否合法
    for (const auto& d : g.demand) {
        CHECK(0 <= d.u && d.u < g.U, "Demand.u 越界: u=" + std::to_string(d.u));
        CHECK(0 <= d.i && d.i < g.I, "Demand.i 越界: i=" + std::to_string(d.i));
        CHECK(0 <= d.t && d.t < g.T, "Demand.t 越界: t=" + std::to_string(d.t));
        CHECK(d.amount >= 0.0, "Demand.amount 需为非负, at " + triple(d.u,d.i,d.t));
    }

    // ================================================================================
    // 7. 验证产能覆盖数据
    // ================================================================================
    // 检查每个产能覆盖项的索引和值是否合法
    for (const auto& c : g.capacity_overrides) {
        CHECK(0 <= c.u && c.u < g.U, "Capacity.u 越界");
        CHECK(0 <= c.t && c.t < g.T, "Capacity.t 越界");
        CHECK(c.value >= 0.0, "Capacity.value 需为非负");
    }

    // ================================================================================
    // 8. 验证初始库存覆盖数据
    // ================================================================================
    // 检查每个初始库存覆盖项的索引和值是否合法
    for (const auto& z : g.i0_overrides) {
        CHECK(0 <= z.u && z.u < g.U, "I0.u 越界");
        CHECK(0 <= z.i && z.i < g.I, "I0.i 越界");
        CHECK(z.value >= 0.0, "I0.value 需为非负");
    }

    // ================================================================================
    // 9. 验证转运相关配置
    // ================================================================================
    if (g.enable_transfer) {
        // 当启用转运功能时，验证转运成本数据
        for (const auto& e : g.transfer_costs) {
            CHECK(0 <= e.u && e.u < g.U, "cT.u 越界");
            CHECK(0 <= e.v && e.v < g.U, "cT.v 越界");
            CHECK(0 <= e.i && e.i < g.I, "cT.i 越界");
            CHECK(0 <= e.t && e.t < g.T, "cT.t 越界");
            CHECK(e.cost >= 0.0, "cT.cost 需为非负, at " + quad(e.u,e.v,e.i,e.t));
        }

        // 验证BigM约束数据
        for (const auto& m : g.bigM) {
            CHECK(0 <= m.i && m.i < g.I, "M.i 越界");
            CHECK(0 <= m.t && m.t < g.T, "M.t 越界");
            CHECK(m.M > 0.0, "M 值需为正");
        }
    } else {
        // 当未启用转运功能时，不应该有转运相关配置
        CHECK(g.transfer_costs.empty(), "enable_transfer=0 时不应提供 transfer_costs");
        CHECK(g.bigM.empty(),           "enable_transfer=0 时不应提供 bigM");
    }
}

/**
 * @brief 生成CSV格式的算例文件
 *
 * @param g 算例生成配置对象
 * @param w CSV写入器对象
 *
 * @throw std::runtime_error 当配置验证失败时抛出异常
 *
 * @details
 * CSV输出严格按照以下顺序（schema）写出数据：
 *
 * 1. meta段 - 元数据
 *    - U: 节点数量
 *    - I: 物品种类数量
 *    - T: 时间周期数量
 *    - enable_transfer: 是否启用转运（0或1）
 *
 * 2. cost段 - 成本数据
 *    - cX[i]: 物品i的X方向生产成本
 *    - cY[i]: 物品i的Y方向生产成本
 *    - cI[i]: 物品i的库存持有成本
 *
 * 3. cap_usage段 - 产能占用数据
 *    - sX[i]: 物品i的X方向产能占用
 *    - sY[i]: 物品i的Y方向产能占用
 *
 * 4. capacity段 - 产能数据
 *    - 先写出所有(u,t)的默认产能
 *    - 再写出覆盖项（会覆盖默认值）
 *
 * 5. init段 - 初始库存数据
 *    - 先写出所有(u,i)的默认初始库存
 *    - 再写出覆盖项（会覆盖默认值）
 *
 * 6. demand段 - 需求数据（稀疏表示）
 *    - 只写出显式配置的需求点
 *    - 未出现的(u,i,t)组合默认需求为0
 *
 * 7. transfer段 - 转运数据（可选，仅当enable_transfer=true）
 *    - cT[u,v,i,t]: 从节点u转运物品i到节点v在时间t的成本
 *
 * 8. bigM段 - BigM约束（可选，仅当enable_transfer=true）
 *    - M[i,t]: 物品i在时间t的BigM值
 *
 * 9. solver段 - 求解器参数
 *    - mip_gap: MIP求解间隙
 *    - time_limit_sec: 时间限制
 *    - threads: 线程数
 *    - sep_violation_eps: 分离违反阈值
 *    - max_iters: 最大迭代次数
 *
 * @note 在写入数据前会自动调用Validate()验证配置的合法性
 */
void CaseGenerator::GenerateCsv(const GeneratorConfig& g, CsvWriter& w) {
    // 首先验证配置的合法性
    Validate(g);

    // ================================================================================
    // 1. 写出 meta 段 - 元数据
    // ================================================================================
    w.writeRow("meta", "U", -1, -1, -1, -1, g.U);
    w.writeRow("meta", "I", -1, -1, -1, -1, g.I);
    w.writeRow("meta", "T", -1, -1, -1, -1, g.T);
    w.writeRow("meta", "enable_transfer", -1, -1, -1, -1, g.enable_transfer ? 1 : 0);

    // ================================================================================
    // 2. 写出 cost 段 - 成本数据
    // ================================================================================
    // 按照 cX -> cY -> cI 的顺序写出每个物品的成本参数
    for (int i = 0; i < g.I; ++i) w.writeRow("cost", "cX", -1, -1, i, -1, g.cX[i]);
    for (int i = 0; i < g.I; ++i) w.writeRow("cost", "cY", -1, -1, i, -1, g.cY[i]);
    for (int i = 0; i < g.I; ++i) w.writeRow("cost", "cI", -1, -1, i, -1, g.cI[i]);

    // ================================================================================
    // 3. 写出 cap_usage 段 - 产能占用数据
    // ================================================================================
    // 按照 sX -> sY 的顺序写出每个物品的产能占用参数
    for (int i = 0; i < g.I; ++i) w.writeRow("cap_usage", "sX", -1, -1, i, -1, g.sX[i]);
    for (int i = 0; i < g.I; ++i) w.writeRow("cap_usage", "sY", -1, -1, i, -1, g.sY[i]);

    // ================================================================================
    // 4. 写出 capacity 段 - 产能数据
    // ================================================================================
    // 策略：先写出所有(u,t)的默认值，再写出覆盖项
    // 读取时，后出现的值会覆盖先出现的值
    for (int u = 0; u < g.U; ++u)
        for (int t = 0; t < g.T; ++t)
            w.writeRow("capacity", "C", u, -1, -1, t, g.default_capacity);

    // 写出覆盖项（会覆盖上面的默认值）
    for (const auto& c : g.capacity_overrides)
        w.writeRow("capacity", "C", c.u, -1, -1, c.t, c.value);

    // ================================================================================
    // 5. 写出 init 段 - 初始库存数据
    // ================================================================================
    // 策略：先写出所有(u,i)的默认值，再写出覆盖项
    for (int u = 0; u < g.U; ++u)
        for (int i = 0; i < g.I; ++i)
            w.writeRow("init", "I0", u, -1, i, -1, g.default_i0);

    // 写出覆盖项（会覆盖上面的默认值）
    for (const auto& z : g.i0_overrides)
        w.writeRow("init", "I0", z.u, -1, z.i, -1, z.value);

    // ================================================================================
    // 6. 写出 demand 段 - 需求数据（稀疏表示）
    // ================================================================================
    // 只写出显式配置的需求点，未出现的默认为0
    for (const auto& d : g.demand)
        w.writeRow("demand", "Demand", d.u, -1, d.i, d.t, d.amount);

    // ================================================================================
    // 7. 写出 transfer 和 bigM 段（可选）
    // ================================================================================
    // 仅当启用转运功能时写出这两个段
    if (g.enable_transfer) {
        // 写出转运成本数据
        for (const auto& e : g.transfer_costs)
            w.writeRow("transfer", "cT", e.u, e.v, e.i, e.t, e.cost);

        // 写出BigM约束数据
        for (const auto& m : g.bigM)
            w.writeRow("bigM", "M", -1, -1, m.i, m.t, m.M);
    }

    // ================================================================================
    // 8. 写出 solver 段 - 求解器参数
    // ================================================================================
    w.writeRow("solver", "mip_gap",           -1, -1, -1, -1, g.mip_gap);
    w.writeRow("solver", "time_limit_sec",    -1, -1, -1, -1, g.time_limit_sec);
    w.writeRow("solver", "threads",           -1, -1, -1, -1, g.threads);
    w.writeRow("solver", "sep_violation_eps", -1, -1, -1, -1, g.sep_violation_eps);
    w.writeRow("solver", "max_iters",         -1, -1, -1, -1, g.max_iters);
}
